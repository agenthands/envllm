# RLM-DSL: v0.1 Stabilization + v0.2 Canonical Mode + Extension Framework
**Single engineering plan (Markdown, ready for execution)**  
**Date:** 2026-02-15 (Europe/Kyiv)

---

## 0) Context (important clarification)

### What already exists
- We already have **RLM-DSL v0.1 implemented and fully tested** in production-like conditions.
- v0.1 already supports the current “web agent” use case sufficiently to execute real workflows.

### What is actually broken
v0.1’s main problem is **LLM output variability**:
- multiple equivalent encodings for the same intent
- drift during retries (renamed vars, reordered steps)
- high dependence on long few-shot prompts or fine-tuning

### What the engineering team must do
**Do not rewrite the system.**  
Engineers must:
1) **Fix the variability problem** by adding a *strict canonical mode* + validator/repair loop.
2) Add a **general extension framework** so new domains (web agent, API DAST, filesystem, etc.) are *plugins/modules*, not “special casing”.
3) Add new features **incrementally** on top of v0.1 and keep v0.1 programs working (compat mode).

### Core architectural stance
**The language is general.**  
A “web agent language” is **just one extension package** (module) providing ops/types for browser automation. The core is a **generic, canonicalizable, typed step DSL** that can host multiple domains.

---

## 1) Goals

### G1 — Stabilize generation without requiring strict planning from the model
Make the DSL “one way to do it” through:
- canonical syntax rules
- canonical formatter
- strict linter
- step-level repair loop

### G2 — Preserve v0.1 investments
- Keep v0.1 tests and semantics
- Run existing v0.1 programs in **compat mode**
- Provide an automated canonicalization path: `v0.1 → v0.2 (canonical)`.

### G3 — Build an extensible platform
- Core language + engine are domain-agnostic
- Domain ops/types are registered via extension modules (packages)
- Web agent is one module; API DAST can be another; etc.

### G4 — Make extensions safe and testable
- Each extension declares:
  - op templates + type signatures
  - runtime handler implementation
  - canonical rules (if any)
  - conformance test fixtures

---

## 2) Non-goals

- We are **not** building a general-purpose programming language.
- We are **not** replacing your existing crawler/DAST implementations.
- We are **not** committing to any specific RL method; we are creating a stable control DSL + execution harness.

---

## 3) v0.1 → v0.2 strategy (compat + strict)

### 3.1 Two modes (must exist)
**Mode A: COMPAT (v0.1 runtime stability)**
- Accepts v0.1 programs and existing syntax variations
- Applies *best-effort* normalization, but does not reject non-canonical forms
- Used for regression tests and production continuity

**Mode B: STRICT (v0.2 canonical dialect)**
- Parser + linter enforce a **single canonical form**
- Formatter produces the canonical form (idempotent)
- Generator harness uses step-level repair and refuses drift

**Acceptance criterion:**  
All v0.1 fixtures continue to pass in COMPAT, and the same fixtures can be **auto-converted** into STRICT output that also passes.

### 3.2 Canonicalization philosophy (borrowed from Anka)
Anka shows that reliability improves when the language:
- offers **one spelling per operation**
- makes state **explicit** (named outputs)
- forces a stable structure (STEP blocks)

Reference: Anka Syntax Guide (principles) and paper.  
See §12 References.

---

## 4) Proposed v0.2 canonical core (minimal delta from v0.1)

This section is the **delta plan**, not a rewrite.

### 4.1 Canonical surface constraints (STRICT mode)
STRICT mode enforces:
1) **No aliases** for ops.
2) **Named parameters only** (no positional).
3) **Fixed clause order** per op.
4) **Explicit outputs** via `INTO <name>: <Type>` when op yields output.
5) **Stable STEP names** (no renaming across repairs).
6) No hidden globals: all state/data is explicitly typed variables.

### 4.2 Two-pass generation protocol (STRICT mode)
- **Pass 1:** Skeleton (step names + ops + INTO targets/types only)
- **Pass 2:** Fill (one step at a time) with validator feedback

### 4.3 Validator pipeline (STRICT mode)
Every program must pass:
1) Parse → AST
2) Canonical lint
3) Typecheck (lightweight)
4) Format (canonical, idempotent)
5) Optional: execute dry-run / capability check

Repair loop must be **step-local**: fix only the failing step, not the entire program.

---

## 5) Extension framework (the “platform” you asked for)

### 5.1 Concept: Packages/Modules
A module is a unit of extension:

- **Module ID:** e.g. `core`, `web`, `api`, `fs`
- **Declared types:** closed set of type names + structural constraints
- **Declared operations:** op name + template + input/output types
- **Runtime handlers:** the code that executes each op
- **Conformance fixtures:** parse/lint/typecheck/format and optional execution tests

### 5.2 Core vs domain packages
- `core` provides: TASK/STEP structure, control ops (ASSERT, WAIT, etc.), type system primitives, validator, formatter, execution interfaces.
- `web` provides: browser automation ops/types (State, ElementRef, UICandidates…), and handlers mapping to your engine (rod/CDP/distiller/EnvStore).
- Future packages can provide ops for:
  - API fuzzing/DAST
  - filesystem workflows
  - CI actions
  - secret scanning workflows (heuristic-guided)
  - etc.

### 5.3 Extension registration API (Go)
**Goal:** New ops/types are added without modifying core.

Recommended interfaces (sketch):

```go
// pkg/dsl/registry
type Module interface {
  ID() string
  Types() []TypeDef
  Operations() []OpDef
  Handlers() map[string]OpHandler // opName -> handler
  Fixtures() []Fixture            // parse/lint/typecheck/format and optional exec tests
}

type Registry interface {
  Register(m Module) error
  ResolveOp(opName string) (OpDef, bool)
  ResolveType(typeName string) (TypeDef, bool)
}
```

### 5.4 Capability gating (important for generality)
Programs can declare required capabilities; the engine validates availability.

Example:
```text
TASK foo:
  REQUIRES capability="web.navigate"
  REQUIRES capability="web.dom.query"
```

This lets the same DSL run across different executors (headless, remote browser, replay-only, etc.).

---

## 6) Web Agent is a module, not “the language”

### 6.1 Web module scope
The web module (`web`) provides:
- `State`, `ElementRef`, `UICandidates`, `Snippets`, etc.
- ops like `NAVIGATE`, `QUERY_DOM`, `PICK`, `CLICK`, `TYPE`, `EXTRACT_TEXT`, etc.
- optional ops: `VISION_QUERY`, `DOC_QUERY` (RLM-lite style)

### 6.2 Extension design requirement
The core must not contain web-specific logic. Core only knows:
- “op name + typed signature + canonical template”
- how to parse/lint/typecheck/format/execute through registry

### 6.3 Why this matters
It makes the whole approach reusable:
- `api` module can re-use the same STEP discipline
- `fs` module can model file ops the same way
- “general approach extended to crawler/DAST” becomes natural: add modules, don’t fork the DSL

---

## 7) Feature additions requested (incremental, aligned with stability)

The team should add features in a way that **reduces freedom**, not increases it.

### F1 — Strict canonical mode + compat mode (must)
- Add `mode=compat|strict` to compiler/runner.
- Add `dsl fmt` that outputs canonical STRICT form.
- Add `dsl check` returning structured errors.

### F2 — Step-local repair contracts (must)
- Standardize validation errors:
  - code, step, span, expected_template, hint
- Add guardrails:
  - “do not rename vars”
  - “step order unchanged”
  - “only edit failing step”
- Add retry limits.

### F3 — Extension module system (must)
- Module registry (types/ops/handlers)
- Fixture-based conformance tests per module
- Capability declarations for runtime validation

### F4 — Canonical option objects (should)
If ops have option objects, enforce:
- stable key ordering
- default omission rules (canonical absence)
- restricted enums over free-form strings

### F5 — Backward compatible canonicalization (should)
Provide an automated conversion for v0.1 programs:
- `dsl migrate --from v0.1 --to v0.2`
- which applies:
  - clause order normalization
  - explicit INTO insertion when inferred safely
  - stable formatting
  - a migration report

---

## 8) Engineering work plan (epics + tasks)

These epics are designed to be executed on top of the existing v0.1 codebase.

### EPIC A — Inventory v0.1 reality
**A1.** Document v0.1 grammar surface area
- Extract list of ops/types used by tests
- Identify alias/optional clause patterns currently accepted

**A2.** Freeze v0.1 fixtures
- Copy v0.1 fixtures into `testdata/v0.1/`
- Ensure they remain unchanged as baseline

**AC:** A stable v0.1 regression suite exists and runs in CI.

---

### EPIC B — Introduce COMPAT vs STRICT parsing
**B1.** Split parser frontend into:
- `CompatParser` (accepts v0.1 variants)
- `StrictParser` (accepts canonical-only)

**B2.** Add unified AST
- Both parsers produce the same AST shape

**AC:** Same AST used in both modes.

---

### EPIC C — Canonical linter + formatter (STRICT)
**C1.** Canonical linter
- enforce clause order
- enforce INTO presence (where required)
- enforce declared ops/types (via registry)
- prohibit aliases (STRICT only)

**C2.** Canonical formatter
- deterministic printing
- idempotence: `fmt(fmt(x)) == fmt(x)`

**AC:** All `testdata/v0.2/` fixtures are idempotent.

---

### EPIC D — Lightweight typecheck
**D1.** Symbol table + type rules from registry definitions
**D2.** Type mismatch errors are structured

**AC:** Type errors are stable and machine-repairable.

---

### EPIC E — Extension framework (Registry + Modules + Handlers)
**E1.** Implement registry interfaces
**E2.** Move existing web ops into `modules/web`
**E3.** Introduce `modules/core` and keep only generic ops there
**E4.** Conformance fixtures per module

**AC:** Adding a new op/type does not require editing core compiler logic.

---

### EPIC F — Generator harness (STRICT mode)
**F1.** Skeleton pass prompt + validator
**F2.** Step-by-step fill pass with repair loop
**F3.** Drift guards: step names, var names, step order locked

**AC:** In STRICT mode, the system converges via step-local repair and does not “rewrite everything”.

---

### EPIC G — Migration tool v0.1 → v0.2 STRICT
**G1.** Implement `dsl migrate`
**G2.** Emit:
- canonical STRICT program
- migration report (what changed and why)

**AC:** Track the percent of v0.1 fixtures auto-migrated without manual edits.

---

### EPIC H — CI, metrics, and definition of done
**H1.** Add CI steps:
- v0.1 suite in COMPAT
- v0.2 suite in STRICT
- idempotence tests
- module fixture tests

**H2.** Add metrics recorder:
- parse_rate, lint_pass_rate, typecheck_pass_rate
- repair iterations per step
- drift violations count

**AC:** CI produces a JSON metrics artifact per run.

---

## 9) Acceptance criteria (definition of done)

### Stability
- STRICT mode rejects all non-canonical variants (no “almost ok”)
- Formatter is idempotent on all v0.2 fixtures
- Step-level repair:
  - changes only the failing step
  - does not rename vars
  - does not reorder steps

### Compatibility
- v0.1 regression suite passes in COMPAT mode unchanged
- v0.1 fixtures migrate to v0.2 STRICT and still pass

### Extensibility
- Web ops/types live in `modules/web`, not core
- A new module can be added with:
  - module registration
  - op/type defs
  - fixtures
  - handlers
  without modifying core compiler logic

---

## 10) Deliverables (files engineering must produce)

### CLI tools
- `dsl check --mode=compat`
- `dsl check --mode=strict`
- `dsl fmt --mode=strict`
- `dsl migrate --from=v0.1 --to=v0.2`
- `dsl run --mode=compat|strict`

### Packages
- `pkg/dsl/ast`
- `pkg/dsl/parse` (compat + strict)
- `pkg/dsl/lint`
- `pkg/dsl/types`
- `pkg/dsl/format`
- `pkg/dsl/registry`

### Modules
- `modules/core`
- `modules/web` (existing web agent ops)
- `modules/...` (future)

### Fixtures
- `testdata/v0.1/*` (baseline)
- `testdata/v0.2/*` (canonical)
- `modules/*/fixtures/*` (module conformance)

---

## 11) Open decisions (make once, then freeze)

1) Grammar tech: PEG vs hand-rolled vs ANTLR (choose based on existing v0.1).
2) AST compatibility: whether v0.2 introduces new nodes or only constraints.
3) Migration inference: where INTO can be inferred safely vs requiring manual edit.
4) Option objects: map syntax vs `options=DEFAULT` enums (recommend enums first).

Document decisions in `docs/decisions/*.md`.

---

## 12) References (design justification)

### Anka (canonical DSL for LLM reliability)
- Paper: https://arxiv.org/abs/2512.23214  
- HTML: https://arxiv.org/html/2512.23214v1  
- Syntax Guide (raw): https://raw.githubusercontent.com/BleBlo/Anka/main/docs/syntax-guide.md  
- Repo: https://github.com/BleBlo/Anka  

### RLM (prompt as environment + query/subcalls)
- Paper: https://arxiv.org/abs/2512.24601  
- HTML: https://arxiv.org/html/2512.24601v1  
- Author blog pointer (code links often live here): https://alexzhang13.github.io/blog/2025/rlm/  

---

## Appendix A — Structured error contract (repair-friendly)

```json
{
  "stage": "lint",
  "errors": [
    {
      "code": "LINT_CLAUSE_ORDER",
      "step": "type_password",
      "span": [120, 188],
      "message": "TYPE clause order must be: target, text, options, in, INTO",
      "expected_template": "TYPE target=<ElementRef> text=<TextOrSecret> options=<TypeOptions> in=<State> INTO <s>: State",
      "hint": "Reorder fields; do not rename variables; do not change other steps."
    }
  ]
}
```
